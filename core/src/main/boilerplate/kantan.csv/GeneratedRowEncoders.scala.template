package kantan.csv

trait GeneratedRowEncoders {
  /** Creates a new [[RowEncoder]] from the specified unary function. */
  def encoder1[C, A1](f: C ⇒ A1)(implicit e1: CellEncoder[A1]): RowEncoder[C] =
    RowEncoder(c ⇒ List(e1.encode(f(c))))
  [2..#/** Creates a new [[RowEncoder]] from the specified function.
    *
    * @param f encoding function.
    [#* @param i1 index of the cell that should be passed as parameter number 1 of `f`#
    ]
    */
  def encoder1[C, [#A1#]](f: C ⇒ Tuple1[[#A1#]])([#i1: Int#])(implicit [#e1: CellEncoder[A1]#]): RowEncoder[C] =
    RowEncoder { c ⇒
      val e = f(c)
      val dest = new Array[String](1)

      [#dest(i1) = e1.encode(e._1)#
      ]
      dest.toSeq
    }#
  ]

  /** Creates a new [[RowEncoder]] from the specified unary function. */
  def ordered1[C, A1: CellEncoder](f: C ⇒ A1): RowEncoder[C] =
    encoder1(f)
  [2..#/** Creates a new [[RowEncoder]] from the specified function.
    *
    * The difference between this and [[encoder1]] is that the former expects CSV cells to be ordered in the exact same
    * sequence as the parameters expected by the specified function, while the later lets you customise these indexes.
    */
    def ordered1[C, [#A1#]](f: C ⇒ Tuple1[[#A1#]])(implicit [#e1: CellEncoder[A1]#]): RowEncoder[C] =
    RowEncoder { c ⇒
      val e = f(c)
      val dest = new Array[String](1)

      [#dest(0) = e1.encode(e._1)#
      ]
      dest.toSeq
    }#
  ]

  /** Creates a new [[RowEncoder]] from the specified `unapply` method of a case class' companion object.
    *
    * This is meant for case classes and is unsafe for any other type: a case class' `unapply` method never returns
    * `Some`, which allows `caseEncoder1` to call `get` on the return value.
    */
  def caseEncoder1[C, A1: CellEncoder](f: C ⇒ Option[A1]): RowEncoder[C] =
    encoder1(f andThen (_.get))
  [2..#/** Creates a new [[RowEncoder]] from the specified `unapply` method of a case class' companion object.
    *
    * This is meant for case classes and is unsafe for any other type: a case class' `unapply` method never returns
    * `Some`, which allows `caseEncoder1` to call `get` on the return value.
    *
    * @param f encoding method, intended to be a case class' `unapply` method.
    [#* @param i1 index of the cell that should be passed as parameter number 1 of `f`#
    ]
    */
    def caseEncoder1[C, [#A1: CellEncoder#]](f: C ⇒ Option[Tuple1[[#A1#]]])([#i1: Int#]): RowEncoder[C] =
      encoder1(f andThen (_.get))([#i1#])#
  ]

  /** Creates a new [[RowEncoder]] from the specified `unapply` method of a case class' companion object. */

  def caseOrdered1[C, A1: CellEncoder](f: C ⇒ Option[A1]): RowEncoder[C] =
    encoder1(f andThen (_.get))
  [2..#/** Creates a new [[RowEncoder]] from the specified `unapply` method of a case class' companion object.
    *
    * The difference between this and [[caseEncoder1]] is that the former expects CSV cells to be ordered in the exact
    * same sequence as the parameters expected by the specified function, while the later lets you customise these
    * indexes.
    *
    * Consider using the `generics` kantan.csv module instead: it can automatically derive instances for this use case.
    */def caseOrdered1[C, [#A1: CellEncoder#]](f: C ⇒ Option[Tuple1[[#A1#]]]): RowEncoder[C] =
    ordered1(f andThen (_.get))#
  ]
}
